% Fichier PROLOG.SYS
% Extrait de "L'ANATOMIE DE PROLOG" par Michel Van Caneghem.


% -----------------------
% Les règles prédéfinies.
% -----------------------

answer(X)       :- internal_call(0).
true            :- internal_call(1).
statistics      :- internal_call(2).

write(X)        :- internal_call(10).
display(X)      :- internal_call(11).
nl              :- internal_call(12).

atom(X)         :- internal_call(20).
integer(X)      :- internal_call(21).
atomic(X)       :- internal_call(22).
var(X)          :- internal_call(23).
list(X)         :- internal_call(24).           % Vérifie si X de la forme [...]
vector(X)       :- internal_call(25).           % Vérifie si X de la forme (...)
function(X)     :- internal_call(26).           % Vérifie si X de la forme f(...)

freezeA(X, But) :- internal_call(30).           % Utilisé par la primitive freeze :
                                                % Si X est lié à une valeur alors on efface But.
                                                % Sinon But sera relancé dès que X change d'état (meme si X est lié à une variable
                                                % plus ancienne).
reduce(X, Y, V) :- internal_call(31).           % Utilisé par la primitive dif :
                                                % Si X et Y sont différents alors reduce provoque un échec.
                                                % Si X et Y sont égaux sans avoir à faire d'hypothèses sur les valeurs des
                                                % variables alors V <-- 1 sinon V représente la première variable sur laquelle
                                                % il faut faire une hypothèse.

listing         :- internal_call(40).
listing(X)      :- internal_call(41).
system          :- internal_call(42).

is(X, Y)        :- internal_call(50).

X < Y           :- internal_call(60).
X =< Y          :- internal_call(61).
X > Y           :- internal_call(62).
X >= Y          :- internal_call(63).

asserta(X)      :- internal_call(70).
assertz(X)      :- internal_call(71).
assert(X)       :- internal_call(71).

echo(X)         :- internal_call(80).

halt            :- internal_call(1000).


% -----------------------------
% Evaluation différée d'un but.
% -----------------------------

freeze(X, But) :- freezeA(X, deep_freeze(X, But)).

deep_freeze(X, But) :- var(X),
                       !,
                       freezeA(X, deep_freeze(X, But)).
deep_freeze(X, But) :- But.


% ------------------------------------------------------------
% Attente de l'égalité des deux arguments pour effacer le but.
% ------------------------------------------------------------

ifeq(X, Y, But) :- reduce(X, Y, V),
                   !,
                   ifeqA(V, X, Y, But).
ifeq(X, Y, But).


ifeqA(V, X, Y, But) :- var(V),
                       !,
                       freezeA(V, ifeq(X, Y, But)).
ifeqA(V, X, Y, But) :- But.


% -------------------------
% Equations sur les arbres.
% -------------------------

X = X.


% ---------------------------
% Inéquations sur les arbres.
% ---------------------------

X \= Y :- reduce(X, Y, V),
          !,
          var(V),
          freezeA(V, X \= Y).
X \= Y.


% ---------------------------------------------------------------------
% Contrainte d'inégalité d'un terme par rapport aux termes d'une liste.
% ---------------------------------------------------------------------

dif(X, []).
dif(X, [T|Q]) :- X \= T,
                 dif(X, Q).


% ------------------------------------------------------
% Contraintes d'inégalité dans une liste, terme à terme.
% ------------------------------------------------------

dif([]).
dif([T|Q]) :- dif(T, Q),
              dif(Q).


% ------------
% La négation.
% ------------

not(P) :- P, !, fail.
not(P).

% ------------------------------------------------------------------------------
% User extension
% ------------------------------------------------------------------------------

abs(X, X) :- X >= 0, !.
abs(X, Y) :- Y is -X.

min(X,Y,X) :- X =< Y.
min(X,Y,Y) :- Y < X.

max(X,Y,X) :- X >= Y.
max(X,Y,Y) :- Y > X.


% Predicate succeeds if infinity or integer
integer_infinity(infinity) :- !.
integer_infinity(+infinity) :- !.
integer_infinity(-infinity) :- !.
integer_infinity(I) :- integer(I).


less_equal(I, infinity) :- integer(I), !.
less_equal(I, +infinity) :- integer(I), !.
less_equal(I1, I2) :- I1 =< I2.


greater_equal(I, -infinity) :- integer(I), !.
greater_equal(I1, I2) :- I1 >= I2.


integer_sequence(To, N) :- integer_sequence(0, To, 1, N).
integer_sequence(From, To, N) :- integer_sequence(From, To, 1, N).
integer_sequence(From, From, 0, From).
integer_sequence(From, To, Step, N) :- integer(From),
                                       integer_infinity(To),
                                       integer(Step),
                                       Step \= 0,
                                       integer_sequence_internal(From, To, Step, N).
% Internal
integer_sequence_internal(From, To, Step, From) :- Step > 0,
                                                   less_equal(From, To).
integer_sequence_internal(From, To, Step, N)    :- Step > 0,
                                                   less_equal(From, To),
                                                   Next is From + Step,
                                                   integer_sequence_internal(Next, To, Step, N).
integer_sequence_internal(From, To, Step, From) :- Step < 0,
                                                   greater_equal(From, To).
integer_sequence_internal(From, To, Step, N)    :- Step < 0,
                                                   greater_equal(From, To),
                                                   Previous is From + Step, % remember: Step is negative
                                                   integer_sequence_internal(Previous, To, Step, N).


% Can be used to check/get the length of a list, or generate a list of a given length, or generate all the lists from 0 to infinity length.
% The length of a non-list is 1.
length(X, Length) :- integer(Length), length_internal(X, Length), !. % When the length is provided, the 1st solution is the good one.
length(X, Length) :-                  length_internal(X, Length).    % When no length provided, all the solutions are enumerated.
% Internal
length_internal([], 0).
length_internal([F|R], L) :- length_internal(R, LR), L is 1+LR.
length_internal(NonList, 1) :- not(list(NonList)).


% Deep length: count the number of items at all levels, calculate the max depth.
% The depth lets make a distinction between lists and non-lists.
% The depth of a non-list is zero.
% The depth of a list's item is the number of [] surrounding the item.
dlength(X, Length, Depth) :- not(var(X)), dlength_internal(X, 0, Length, Depth).    % When no length and/or no depth provided, all the solutions are enumerated.
% Internal
dlength_internal([], L, L, 1).
dlength_internal([F|R], _, L, D)  :- dlength_internal(F, 1, LF, DF), dlength_internal(R, 0, LR, DR), L is LF+LR, DFplus1 is DF+1, max(DFplus1, DR, D).
dlength_internal(NonList, _, 1, 0) :- not(list(NonList)).
